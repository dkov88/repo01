Дополнительные задачи для самопроверки

1) Создать переменную для строки "dniMyMdegnahCybuR" . Написать однострочную инструкцию, которая поменяет порядок букв на противоположный и снизит все буквы в регистре кроме первой. Вывести результат. Значение оригинальной переменной должно быть изменено.

2.4.1 :112 > string = "dniMyMdegnahCybuR"
 => "dniMyMdegnahCybuR" 
2.4.1 :113 > string.reverse.downcase.capitalize
 => "Rubychangedmymind"

2) Дано семизначное число. Вывести на экран число, где первая цифра стала последней, вторая ‐ предпоследней и тд.

2.4.1 :110 > t = 7654321
 => 7654321 
2.4.1 :111 > puts t.to_s.reverse.to_i
1234567
 => nil 


3.1) Дано целое число. Найти и вывести сумму его цифр


2.4.1 :022 > x = 12345
 => 12345 
2.4.1 :023 > a = x.to_s.split('')
 => ["1", "2", "3", "4", "5"] 
2.4.1 :024 > puts a.inject(0){|sum, x| sum + x.to_i}
15
 => nil

3.2) Дана строка. Необходимо подсчитать количество букв "а" в этой строке (независимо от регистра)

2.4.1 :038 > puts "AAAsdeaaase".count('a|A')
6
 => nil

4) Дана строка. Проверить, является ли она палиндромом 

2.4.1 :052 > str = "ababa"
 => "ababa" 
2.4.1 :053 > puts 'palindrom' if str == str.reverse
palindrom
 => nil 
2.4.1 :054 > str = "noanas"
 => "noanas" 
2.4.1 :055 > puts 'palindrom' if str == str.reverse
 => nil 

5) Вывести на экран числа от 10 до 3 не включая 5, причём числа, кратные 3м, вывести в квадрате

 
(3..10).to_a.reverse.each do |x|
	if x % 3 == 0 
	  puts x**2
  elsif x == 5
  else
    puts x
  end
end

6) Дан хэш:


2.4.1 :033 > shop = {
2.4.1 :034 >        milk: 10,
2.4.1 :035 >        bread: 8,
2.4.1 :036 >        cornflakes: 12,
2.4.1 :037 >        ice_cream: 15,
2.4.1 :038 >        pie: 20
2.4.1 :039?>   }
 => {:milk=>10, :bread=>8, :cornflakes=>12, :ice_cream=>15, :pie=>20} 

Ответить на вопрос: если ли в магазине какой‐либо продукт с ценой в 15?

2.4.1 :040 > shop.each { |k, v| puts "It exists" if v == 15 }
It exists
 => {:milk=>10, :bread=>8, :cornflakes=>12, :ice_cream=>15, :pie=>20}


7) Дан массив ar = [1, 6,1,8,2,-1,3,5] . Прибавить 100 к его максимальному элементу:

2.4.1 :079 > ar = [1, 6,1,8,2,-1,3,5] 
 => [1, 6, 1, 8, 2, -1, 3, 5] 
2.4.1 :080 > b = ar.index(ar.max)
 => 3 
2.4.1 :081 > ar[b] += 100
 => 108 
2.4.1 :082 > p ar
[1, 6, 1, 108, 2, -1, 3, 5]
 => [1, 6, 1, 108, 2, -1, 3, 5]


8) Дан массив: ar = [7, 3, [4, 5, 1], 1, 9, [2, 8, 1]].  Вывести отсортированный по убыванию массив из уникальных элементов начального массива 


2.4.1 :108 > ar = [7, 3, [4, 5, 1], 1, 9, [2, 8, 1]]
 => [7, 3, [4, 5, 1], 1, 9, [2, 8, 1]] 
2.4.1 :109 > p ar.flatten.uniq.sort { |x,y| y <=> x }
[9, 8, 7, 5, 4, 3, 2, 1]
 => [9, 8, 7, 5, 4, 3, 2, 1]
